import { __decorate } from 'tslib';
import { Directive, TemplateRef, ViewContainerRef, Component, ChangeDetectionStrategy, ElementRef, NgZone, ContentChild, HostListener, Injector, APP_INITIALIZER, NgModule } from '@angular/core';
import { fromEvent } from 'rxjs';
import { DOCUMENT, CommonModule } from '@angular/common';
import { applyPolyfills, defineCustomElements } from '@ionic-selectable/core/loader';
import { NgControl, NG_VALUE_ACCESSOR } from '@angular/forms';

/* eslint-disable */
const proxyInputs = (Cmp, inputs) => {
    const Prototype = Cmp.prototype;
    inputs.forEach(item => {
        Object.defineProperty(Prototype, item, {
            get() {
                return this.el[item];
            },
            set(val) {
                this.z.runOutsideAngular(() => (this.el[item] = val));
            }
        });
    });
};
const proxyMethods = (Cmp, methods) => {
    const Prototype = Cmp.prototype;
    methods.forEach(methodName => {
        Prototype[methodName] = function () {
            const args = arguments;
            return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));
        };
    });
};
const proxyOutputs = (instance, el, events) => {
    events.forEach(eventName => instance[eventName] = fromEvent(el, eventName));
};
function ProxyCmp(opts) {
    const decorator = function (cls) {
        if (opts.inputs) {
            proxyInputs(cls, opts.inputs);
        }
        if (opts.methods) {
            proxyMethods(cls, opts.methods);
        }
        return cls;
    };
    return decorator;
}

class IonicSelectableItemTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableItemTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableItemTemplate]'
            },] }
];
IonicSelectableItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableAddItemTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableAddItemTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableAddItemTemplate]'
            },] }
];
IonicSelectableAddItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableCloseButtonTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableCloseButtonTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableCloseButtonTemplate]',
            },] }
];
IonicSelectableCloseButtonTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableFooterTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableFooterTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableFooterTemplate]',
            },] }
];
IonicSelectableFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableGroupEndTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableGroupEndTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableGroupEndTemplate]',
            },] }
];
IonicSelectableGroupEndTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableGroupTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableGroupTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableGroupTemplate]',
            },] }
];
IonicSelectableGroupTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableHeaderTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableHeaderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableHeaderTemplate]',
            },] }
];
IonicSelectableHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableIconTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableIconTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableIconTemplate]',
            },] }
];
IonicSelectableIconTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableItemEndTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableItemEndTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableItemEndTemplate]',
            },] }
];
IonicSelectableItemEndTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableItemIconTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableItemIconTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableItemIconTemplate]',
            },] }
];
IonicSelectableItemIconTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableMessageTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableMessageTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableMessageTemplate]',
            },] }
];
IonicSelectableMessageTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectablePlaceholderTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectablePlaceholderTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectablePlaceholderTemplate]',
            },] }
];
IonicSelectablePlaceholderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableSearchFailTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableSearchFailTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableSearchFailTemplate]',
            },] }
];
IonicSelectableSearchFailTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableTitleTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableTitleTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableTitleTemplate]',
            },] }
];
IonicSelectableTitleTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

class IonicSelectableValueTemplateDirective {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
}
IonicSelectableValueTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ionicSelectableValueTemplate]',
            },] }
];
IonicSelectableValueTemplateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];

let IonicSelectableComponent = class IonicSelectableComponent {
    constructor(elementRef, z, viewContainerRef) {
        this.elementRef = elementRef;
        this.z = z;
        this.viewContainerRef = viewContainerRef;
        this.refMap = new WeakMap();
        this.el = this.elementRef.nativeElement;
        this.el.templateRender = this.render.bind(this);
        this.el.hasTemplateRender = this.hasTemplate.bind(this);
        proxyOutputs(this, this.el, [
            'infiniteScrolled',
            'searching',
            'searchFailed',
            'searchSuccessed',
            'itemAdding',
            'cleared',
            'changed',
            'itemsChanged',
            'selected',
            'opened',
            'closed',
            'focused',
            'blurred',
        ]);
    }
    render(element, template) {
        this.z.run(() => {
            if (template.type === 'addItem') {
                if (!element) {
                    this.refAddItem = null;
                    return;
                }
                if (!this.refAddItem) {
                    this.createEmbeddedView(element, template);
                }
                else {
                    this.updateEmbeddedView(element, template);
                }
            }
            else {
                if (!element.isConnected && element.firstElementChild) {
                    this.refMap.delete(element);
                    return;
                }
                if (!this.refMap.get(element)) {
                    this.createEmbeddedView(element, template);
                }
                else {
                    this.updateEmbeddedView(element, template);
                }
            }
        });
    }
    createEmbeddedView(element, template) {
        const node = this.viewContainerRef.createEmbeddedView(this.getComponent(template.type), {
            $implicit: template.value,
            isItemSelected: template.isItemSelected,
            isItemDisabled: template.isItemDisabled,
            isAdd: template.isAdd,
            type: template.type,
        });
        const childElement = getElement(node);
        element.appendChild(childElement);
        if (template.type === 'addItem') {
            childElement.classList.add('ion-page');
            this.refAddItem = node;
        }
        else {
            this.refMap.set(element, node);
        }
        // run sync change detections
        node.detectChanges();
    }
    updateEmbeddedView(element, template) {
        const node = template.type === 'addItem' ? this.refAddItem : this.refMap.get(element);
        const ctx = node.context;
        if (template.type !== ctx.type) {
            element.removeChild(element.lastChild);
            this.createEmbeddedView(element, template);
            return;
        }
        ctx.$implicit = template.value;
        ctx.isItemSelected = template.isItemSelected;
        ctx.isItemDisabled = template.isItemDisabled;
        ctx.isAdd = template.isAdd;
        // run sync change detections
        node.detectChanges();
    }
    hasTemplate(type) {
        switch (type) {
            case 'addItem':
                return !!this.ionicSelectableAddItemTemplateDirective;
            case 'closeButton':
                return !!this.ionicSelectableCloseButtonTemplateDirective;
            case 'footer':
                return !!this.ionicSelectableFooterTemplateDirective;
            case 'groupEnd':
                return !!this.ionicSelectableGroupEndTemplateDirective;
            case 'group':
                return !!this.ionicSelectableGroupTemplateDirective;
            case 'header':
                return !!this.ionicSelectableHeaderTemplateDirective;
            case 'icon':
                return !!this.ionicSelectableIconTemplateDirective;
            case 'item':
                return !!this.ionicSelectableItemTemplateDirective;
            case 'itemEnd':
                return !!this.ionicSelectableItemEndTemplateDirective;
            case 'itemIcon':
                return !!this.ionicSelectableItemIconTemplateDirective;
            case 'message':
                return !!this.ionicSelectableMessageTemplateDirective;
            case 'placeholder':
                return !!this.ionicSelectablePlaceholderTemplateDirective;
            case 'searchFail':
                return !!this.ionicSelectableSearchFailTemplateDirective;
            case 'title':
                return !!this.ionicSelectableTitleTemplateDirective;
            case 'value':
                return !!this.ionicSelectableValueTemplateDirective;
            default:
                return false;
        }
    }
    getComponent(type) {
        switch (type) {
            case 'addItem':
                return this.ionicSelectableAddItemTemplateDirective.templateRef;
            case 'closeButton':
                return this.ionicSelectableCloseButtonTemplateDirective.templateRef;
            case 'footer':
                return this.ionicSelectableFooterTemplateDirective.templateRef;
            case 'groupEnd':
                return this.ionicSelectableGroupEndTemplateDirective.templateRef;
            case 'group':
                return this.ionicSelectableGroupTemplateDirective.templateRef;
            case 'header':
                return this.ionicSelectableHeaderTemplateDirective.templateRef;
            case 'icon':
                return this.ionicSelectableIconTemplateDirective.templateRef;
            case 'item':
                return this.ionicSelectableItemTemplateDirective.templateRef;
            case 'itemEnd':
                return this.ionicSelectableItemEndTemplateDirective.templateRef;
            case 'itemIcon':
                return this.ionicSelectableItemIconTemplateDirective.templateRef;
            case 'message':
                return this.ionicSelectableMessageTemplateDirective.templateRef;
            case 'placeholder':
                return this.ionicSelectablePlaceholderTemplateDirective.templateRef;
            case 'searchFail':
                return this.ionicSelectableSearchFailTemplateDirective.templateRef;
            case 'title':
                return this.ionicSelectableTitleTemplateDirective.templateRef;
            case 'value':
                return this.ionicSelectableValueTemplateDirective.templateRef;
            default:
                throw new Error(`template for ${type} was not provided`);
        }
    }
};
IonicSelectableComponent.decorators = [
    { type: Component, args: [{
                selector: 'ionic-selectable',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: [
                    'isOpened',
                    'isDisabled',
                    'placeholder',
                    'closeButtonText',
                    'closeButtonSlot',
                    'itemIconSlot',
                    'confirmButtonText',
                    'clearButtonText',
                    'addButtonText',
                    'name',
                    'selectedText',
                    'isMultiple',
                    'value',
                    'shouldStoreItemValue',
                    'items',
                    'disabledItems',
                    'itemValueField',
                    'itemTextField',
                    'shouldBackdropClose',
                    'modalCssClass',
                    'modalEnterAnimation',
                    'modalLeaveAnimation',
                    'titleText',
                    'groupValueField',
                    'groupTextField',
                    'hasInfiniteScroll',
                    'infiniteScrollThreshold',
                    'hasVirtualScroll',
                    'virtualScrollApproxHeaderHeight',
                    'virtualScrollApproxItemHeight',
                    'hasConfirmButton',
                    'canAddItem',
                    'canClear',
                    'canSearch',
                    'shouldDelegateSearchToEvent',
                    'searchDebounce',
                    'searchPlaceholder',
                    'searchText',
                    'shouldFocusSearchbar',
                    'hasSearchText',
                    'searchCancelButtonIcon',
                    'searchCancelButtonText',
                    'searchClearIcon',
                    'searchInputmode',
                    'searchIcon',
                    'searchShowCancelButton',
                    'isConfirmButtonEnabled',
                    'headerColor',
                    'groupColor',
                    'virtualScrollHeaderFn',
                ]
            },] }
];
IonicSelectableComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ViewContainerRef }
];
IonicSelectableComponent.propDecorators = {
    ionicSelectableAddItemTemplateDirective: [{ type: ContentChild, args: [IonicSelectableAddItemTemplateDirective, { static: false },] }],
    ionicSelectableCloseButtonTemplateDirective: [{ type: ContentChild, args: [IonicSelectableCloseButtonTemplateDirective, { static: false },] }],
    ionicSelectableFooterTemplateDirective: [{ type: ContentChild, args: [IonicSelectableFooterTemplateDirective, { static: false },] }],
    ionicSelectableGroupEndTemplateDirective: [{ type: ContentChild, args: [IonicSelectableGroupEndTemplateDirective, { static: false },] }],
    ionicSelectableGroupTemplateDirective: [{ type: ContentChild, args: [IonicSelectableGroupTemplateDirective, { static: false },] }],
    ionicSelectableHeaderTemplateDirective: [{ type: ContentChild, args: [IonicSelectableHeaderTemplateDirective, { static: false },] }],
    ionicSelectableIconTemplateDirective: [{ type: ContentChild, args: [IonicSelectableIconTemplateDirective, { static: false },] }],
    ionicSelectableItemEndTemplateDirective: [{ type: ContentChild, args: [IonicSelectableItemEndTemplateDirective, { static: false },] }],
    ionicSelectableItemIconTemplateDirective: [{ type: ContentChild, args: [IonicSelectableItemIconTemplateDirective, { static: false },] }],
    ionicSelectableItemTemplateDirective: [{ type: ContentChild, args: [IonicSelectableItemTemplateDirective, { static: false },] }],
    ionicSelectableMessageTemplateDirective: [{ type: ContentChild, args: [IonicSelectableMessageTemplateDirective, { static: false },] }],
    ionicSelectablePlaceholderTemplateDirective: [{ type: ContentChild, args: [IonicSelectablePlaceholderTemplateDirective, { static: false },] }],
    ionicSelectableSearchFailTemplateDirective: [{ type: ContentChild, args: [IonicSelectableSearchFailTemplateDirective, { static: false },] }],
    ionicSelectableTitleTemplateDirective: [{ type: ContentChild, args: [IonicSelectableTitleTemplateDirective, { static: false },] }],
    ionicSelectableValueTemplateDirective: [{ type: ContentChild, args: [IonicSelectableValueTemplateDirective, { static: false },] }]
};
IonicSelectableComponent = __decorate([
    ProxyCmp({
        inputs: [
            'isOpened',
            'isDisabled',
            'placeholder',
            'closeButtonText',
            'closeButtonSlot',
            'itemIconSlot',
            'confirmButtonText',
            'clearButtonText',
            'addButtonText',
            'name',
            'selectedText',
            'isMultiple',
            'value',
            'shouldStoreItemValue',
            'items',
            'disabledItems',
            'itemValueField',
            'itemTextField',
            'shouldBackdropClose',
            'modalCssClass',
            'modalEnterAnimation',
            'modalLeaveAnimation',
            'titleText',
            'groupValueField',
            'groupTextField',
            'hasInfiniteScroll',
            'infiniteScrollThreshold',
            'hasVirtualScroll',
            'virtualScrollApproxHeaderHeight',
            'virtualScrollApproxItemHeight',
            'hasConfirmButton',
            'canAddItem',
            'canClear',
            'canSearch',
            'shouldDelegateSearchToEvent',
            'searchDebounce',
            'searchPlaceholder',
            'searchText',
            'shouldFocusSearchbar',
            'hasSearchText',
            'searchCancelButtonIcon',
            'searchCancelButtonText',
            'searchClearIcon',
            'searchInputmode',
            'searchIcon',
            'searchShowCancelButton',
            'isConfirmButtonEnabled',
            'headerColor',
            'groupColor',
            'virtualScrollHeaderFn',
        ],
        methods: [
            'hasValue',
            'open',
            'close',
            'getItemsToConfirm',
            'confirm',
            'clear',
            'enableInfiniteScroll',
            'disableInfiniteScroll',
            'endInfiniteScroll',
            'scrollToTop',
            'scrollToBottom',
            'startSearch',
            'endSearch',
            'showLoading',
            'hideLoading',
            'addItem',
            'deleteItem',
            'toggleItems',
            'showAddItemTemplate',
            'hideAddItemTemplate',
            '',
        ],
    })
], IonicSelectableComponent);
const getElement = (view) => {
    const rootNodes = view.rootNodes;
    for (let i = 0; i < rootNodes.length; i++) {
        if (rootNodes[i].nodeType === 1) {
            return rootNodes[i];
        }
    }
    throw new Error('element was not created');
};
const ɵ0$1 = getElement;

const raf = (h) => {
    if (typeof __zone_symbol__requestAnimationFrame === 'function') {
        return __zone_symbol__requestAnimationFrame(h);
    }
    if (typeof requestAnimationFrame === 'function') {
        return requestAnimationFrame(h);
    }
    return setTimeout(h);
};

let didInitialize = false;
const appInitialize = (doc, zone) => {
    return () => {
        const win = doc.defaultView;
        if (win && typeof window !== 'undefined') {
            if (didInitialize) {
                console.warn('IonicSelectable Angular was already initialized. Make sure IonicSelectableModule.forRoot() is just called once.');
            }
            didInitialize = true;
            const aelFn = '__zone_symbol__addEventListener' in doc.body
                ? '__zone_symbol__addEventListener'
                : 'addEventListener';
            return applyPolyfills().then(() => {
                return defineCustomElements(win, {
                    syncQueue: true,
                    raf,
                    jmp: (h) => zone.runOutsideAngular(h),
                    ael(elm, eventName, cb, opts) {
                        elm[aelFn](eventName, cb, opts);
                    },
                    rel(elm, eventName, cb, opts) {
                        elm.removeEventListener(eventName, cb, opts);
                    }
                });
            });
        }
    };
};

class ValueAccessor {
    constructor(injector, el) {
        this.injector = injector;
        this.el = el;
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    writeValue(value) {
        /**
         * TODO for Ionic 6:
         * Change `value == null ? '' : value;`
         * to `value`. This was a fix for IE9, but IE9
         * is no longer supported; however, this change
         * is potentially a breaking change
         */
        this.el.nativeElement.value = this.lastValue = value == null ? '' : value;
        setIonicClasses(this.el);
    }
    handleChangeEvent(el, value) {
        if (el === this.el.nativeElement) {
            if (value !== this.lastValue) {
                this.lastValue = value;
                this.onChange(value);
            }
            setIonicClasses(this.el);
        }
    }
    _handleBlurEvent(el) {
        if (el === this.el.nativeElement) {
            this.onTouched();
            setIonicClasses(this.el);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.el.nativeElement.disabled = isDisabled;
    }
    ngOnDestroy() {
        if (this.statusChanges) {
            this.statusChanges.unsubscribe();
        }
    }
    ngAfterViewInit() {
        let ngControl;
        try {
            ngControl = this.injector.get(NgControl);
        }
        catch ( /* No FormControl or ngModel binding */_a) { /* No FormControl or ngModel binding */ }
        if (!ngControl) {
            return;
        }
        // Listen for changes in validity, disabled, or pending states
        if (ngControl.statusChanges) {
            this.statusChanges = ngControl.statusChanges.subscribe(() => setIonicClasses(this.el));
        }
        /**
         * TODO Remove this in favor of https://github.com/angular/angular/issues/10887
         * whenever it is implemented. Currently, Ionic's form status classes
         * do not react to changes when developers manually call
         * Angular form control methods such as markAsTouched.
         * This results in Ionic's form status classes being out
         * of sync with the ng form status classes.
         * This patches the methods to manually sync
         * the classes until this feature is implemented in Angular.
         */
        const formControl = ngControl.control;
        if (formControl) {
            const methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];
            methodsToPatch.forEach(method => {
                if (formControl[method]) {
                    const oldFn = formControl[method].bind(formControl);
                    formControl[method] = (...params) => {
                        oldFn(...params);
                        setIonicClasses(this.el);
                    };
                }
            });
        }
    }
}
ValueAccessor.propDecorators = {
    _handleBlurEvent: [{ type: HostListener, args: ['blurred', ['$event.target'],] }]
};
const setIonicClasses = (element) => {
    raf(() => {
        const input = element.nativeElement;
        const classes = getClasses(input);
        setClasses(input, classes);
        const item = input.closest('ion-item');
        if (item) {
            setClasses(item, classes);
        }
    });
};
const getClasses = (element) => {
    const classList = element.classList;
    const classes = [];
    for (let i = 0; i < classList.length; i++) {
        const item = classList.item(i);
        if (item !== null && startsWith(item, 'ng-')) {
            classes.push(`ion-${item.substr(3)}`);
        }
    }
    return classes;
};
const ɵ0 = getClasses;
const setClasses = (element, classes) => {
    const classList = element.classList;
    [
        'ion-valid',
        'ion-invalid',
        'ion-touched',
        'ion-untouched',
        'ion-dirty',
        'ion-pristine'
    ].forEach(c => classList.remove(c));
    classes.forEach(c => classList.add(c));
};
const ɵ1 = setClasses;
const startsWith = (input, search) => {
    return input.substr(0, search.length) === search;
};
const ɵ2 = startsWith;

class IonicSelectableValueAccessor extends ValueAccessor {
    constructor(injector, el) {
        super(injector, el);
    }
    _handleChangeEvent(el) {
        this.handleChangeEvent(el, el.value);
    }
}
IonicSelectableValueAccessor.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line:directive-selector */
                selector: 'ionic-selectable',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IonicSelectableValueAccessor,
                        multi: true
                    }
                ]
            },] }
];
IonicSelectableValueAccessor.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef }
];
IonicSelectableValueAccessor.propDecorators = {
    _handleChangeEvent: [{ type: HostListener, args: ['changed', ['$event.target'],] }]
};

const DECLARATIONS = [
    //Component
    IonicSelectableComponent,
    //Value accesor
    IonicSelectableValueAccessor,
    //Directives,
    IonicSelectableAddItemTemplateDirective,
    IonicSelectableCloseButtonTemplateDirective,
    IonicSelectableFooterTemplateDirective,
    IonicSelectableGroupEndTemplateDirective,
    IonicSelectableGroupTemplateDirective,
    IonicSelectableHeaderTemplateDirective,
    IonicSelectableIconTemplateDirective,
    IonicSelectableItemEndTemplateDirective,
    IonicSelectableItemIconTemplateDirective,
    IonicSelectableItemTemplateDirective,
    IonicSelectableMessageTemplateDirective,
    IonicSelectablePlaceholderTemplateDirective,
    IonicSelectableSearchFailTemplateDirective,
    IonicSelectableTitleTemplateDirective,
    IonicSelectableValueTemplateDirective
];
class IonicSelectableModule {
    static forRoot() {
        return {
            ngModule: IonicSelectableModule,
            providers: [
                {
                    provide: APP_INITIALIZER,
                    useFactory: appInitialize,
                    multi: true,
                    deps: [
                        DOCUMENT,
                        NgZone
                    ]
                }
            ]
        };
    }
}
IonicSelectableModule.decorators = [
    { type: NgModule, args: [{
                declarations: DECLARATIONS,
                exports: DECLARATIONS,
                imports: [CommonModule]
            },] }
];

//COMPONENT

/**
 * Generated bundle index. Do not edit.
 */

export { IonicSelectableComponent, IonicSelectableModule, ProxyCmp as ɵa, IonicSelectableAddItemTemplateDirective as ɵb, IonicSelectableCloseButtonTemplateDirective as ɵd, IonicSelectableFooterTemplateDirective as ɵe, IonicSelectableGroupEndTemplateDirective as ɵf, IonicSelectableGroupTemplateDirective as ɵg, IonicSelectableHeaderTemplateDirective as ɵh, IonicSelectableIconTemplateDirective as ɵi, IonicSelectableItemEndTemplateDirective as ɵj, IonicSelectableItemIconTemplateDirective as ɵk, IonicSelectableItemTemplateDirective as ɵl, IonicSelectableMessageTemplateDirective as ɵm, IonicSelectablePlaceholderTemplateDirective as ɵn, IonicSelectableSearchFailTemplateDirective as ɵo, IonicSelectableTitleTemplateDirective as ɵp, IonicSelectableValueTemplateDirective as ɵq, IonicSelectableValueAccessor as ɵr, ValueAccessor as ɵs, appInitialize as ɵt };
//# sourceMappingURL=ionic-selectable-angular.js.map
